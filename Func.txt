#include <Arduino.h>
#include <array>
#include <QTRSensors.h>

QTRSensors qtr;

class sensorData {
    public:
    int size=5;
    int mostRecentData[5];
    std::array<int,5> previousData;
    int numberthingy[5]={50,25,1,-25,-50}; //Midten her burde egentlig være 0, men med få sensorer så kan det gi issue med allWhite funksjonen
    bool allWhite=false;
    sensorData() {
      qtr.setTypeRC(); // or setTypeAnalog()
    qtr.setSensorPins((const uint8_t[]){D2, D4, D9, D7, D8}, size);
    for (uint8_t i = 0; i < 250; i++)
    {qtr.calibrate();
       //Serial.println("Calibratin");
        delay(20); //hvis vi ikke har denne så blir den aldri ferdig, kan hende vi kan minke den då
        }

    }

    float seData() {
        float avik=0; //Denne vi endrer for å lese
        allWhite=true;
        for (int element: mostRecentData){
            //Serial.print(element);
            if (element != 0){
                allWhite=false;
                //allWhite=false;
            }
            //Serial.println(element);
            avik+=element;
            //Serial.print(",");
        }
        //Serial.println(" ");
        return avik;
    }

    void update() {
        digitalWrite(D2,HIGH); // VELDIG VELDIG viktig , må gjøre det for hver av sensorene
        digitalWrite(D4,HIGH);

        digitalWrite(D7,HIGH);
        digitalWrite(D8,HIGH);
        
        digitalWrite(D9,HIGH);
        //analogWrite(1,HIGH);
        //analogWrite(2,HIGH);
        uint16_t sensors[size];
        int16_t position = qtr.readLineBlack(sensors);
        for (int j = 0; j<size;j++){
                previousData[j]=mostRecentData[j];
            }
        for (uint8_t i = 0; i < size; i++)
        {
            
            
            int threshold = 400;
            if (sensors[i]<threshold){
                mostRecentData[i]=1;
            }
            else{
                mostRecentData[i]=0;
            }
            
            //mostRecentData[i]=sensors[i];

            //Serial.println(mostRecentData[i]);
            //if (i < size-1) Serial.print(", ");
        }
        for (int i =0; i<size; i++){
           
            mostRecentData[i]=mostRecentData[i]*numberthingy[i];
            if (mostRecentData[i] >0){
                allWhite=false;
            }
        }
        
        //Serial.println("");
    }

    bool checkForAllWhite(){
            return allWhite;
        }
    std::array<int,5> getLastLine(){
        return previousData;
    }
};

class motor{
    public:
    motor(int stby, int PMW,int dir1, int dir2):stby(stby),PMW(PMW),dir1(dir1),dir2(dir2){
        pinMode(dir1,OUTPUT);
        pinMode(dir2,OUTPUT);
        pinMode(stby,OUTPUT);
        pinMode(PMW,OUTPUT);

    }
    void panikkSnu(bool framover){
        if (framover){
            digitalWrite(dir1,HIGH);
            digitalWrite(dir2,LOW);
        }
        else{
            digitalWrite(dir2,HIGH);
            digitalWrite(dir1,LOW);
        }
        analogWrite(PMW,255);
    }

    void drive(int power){
        power=power*directionalMultiplier;
      digitalWrite(stby,HIGH);
      if (power <0){
        //forward=false;
        //power=power*(-1); //okay, så planen er nå at den alltid skal kjøre framover og bare svinge med å minke og legge til dingser
      }
      else if (power > 0){
        forward=true;
      }
         if (forward){
            digitalWrite(dir1,HIGH);
            digitalWrite(dir2,LOW);
         }
         else{
            digitalWrite(dir2,HIGH);
            digitalWrite(dir1,LOW);
         }
         int pwm = power + drivingVariable;
        pwm = constrain(pwm, 0, 255);
        Serial.println(pwm);

         analogWrite(PMW,power+drivingVariable);

    }
    int stby;
    int PMW;
    int dir1;
    int dir2;
    float drivingVariable=100;
    bool forward=true;
    int directionalMultiplier=1;
};
//tilstandsmaskinnnn
float input = 100;
bool serLinje = false;

float forgjeAvik = 0.0;
float integral = 0.0;
float deriverte=0.0;

float K_P = 0.1;
float K_I = 0.1;
float K_D = 0.1;


float PID2(float avik) {
    integral += avik;
    float derivative = avik - forgjeAvik;
    float output = K_P * avik + K_I * integral + K_D * derivative;
    forgjeAvik = avik;
    if (output >=250){
        output=249;
        integral-=avik;
    }
    else if(output <=-250){
        output=-249;
        integral+=avik;
    }
    return output;
}





motor motor1(PC5,PA6,PC8,PC6); //PB1
motor motor2(PC5,PB6,PC9,PB8); //PA8 //PB6

void setup() {
    Serial.begin(9600); // Start serial communication
    motor2.directionalMultiplier=-1;
    Serial.println("Calibration Comence!");
}

float flag=0;
sensorData sensor;
float FlagAvik=0;

void panikk(sensorData& sensor,motor& motor1,motor& motor2){
    
}
int mengdepanikk=0;
void loop() {
    float response=0;
    sensor.update();
    if (sensor.checkForAllWhite()){
        mengdepanikk+=1;
        Serial.println("All white");
        int size= 5;
        std::array<int,5> last=sensor.getLastLine();
        //bassert på hva last sist så så må vi ta en stor sving den veien.
        if (mengdepanikk>3){
            float panikkvei=0;
            for (int i =0; i<size; i++){
                panikkvei+=last[i];
            }
            if (panikkvei >= 0){
                //motor kjør en av veiene
                motor1.panikkSnu(true);
                motor2.panikkSnu(false);   
            }
            else{
                motor1.panikkSnu(false);
                motor2.panikkSnu(true);   
            }
            mengdepanikk=0;
        }
    }
    else{
        float avik = sensor.seData();
         response = PID2(-avik); //-avik fordi det er sånn motorene våre er satt IRL

        // Serial.print(avik);
    //Serial.print("; ");
    //Serial.println(response);
    

    //FlagAvik=avik;
    
    }
    
    
    motor1.drive(response);
    motor2.drive(response);
   
}


//Issues
//Enn så lenge så fungerer ikke PID'en nokk til å være hele styresystemet
//Samt så har vi ikke nokk inputs fra sensoren til å detektere sentrum.
//Noe som betyr at AllWhite blir kalt oftere enn forventet
//samtidig som ALLWHite ikke fungerer som forventet, ettersom den bare lar bilen kjøre rett fram, mens den egentlig skal svinge brått.
