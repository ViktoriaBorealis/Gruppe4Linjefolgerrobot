#include <Arduino.h>

#include <QTRSensors.h>

QTRSensors qtr;

class sensorData {
    public:
    int size=4;
    int mostRecentData[4];
    sensorData() {
      qtr.setTypeRC(); // or setTypeAnalog()
    qtr.setSensorPins((const uint8_t[]){A0, A1, A4, A5}, size);
    for (uint8_t i = 0; i < 250; i++)
    {qtr.calibrate();
        delay(20); //hvis vi ikke har denne så blir den aldri ferdig, kan hende vi kan minke den då
        }

    }

    float seData() {
        float avik=10; //Denne vi endrer for å lese
        for (int element: mostRecentData){
            Serial.print(element);
            Serial.print(",");
        }
        Serial.println(" ");
        return avik;
    }

    void update() {
        analogWrite(A0,HIGH); // VELDIG VELDIG , må gjøre det for hver av sensorene
        analogWrite(A1,HIGH);

        analogWrite(A4,HIGH);
        analogWrite(A5,HIGH);
        
        //analogWrite(1,HIGH);
        //analogWrite(2,HIGH);
        uint16_t sensors[size];
        int16_t position = qtr.readLineBlack(sensors);
        for (uint8_t i = 0; i < size; i++)
        {
            int threshold = 400;
            if (sensors[i]<threshold){
                mostRecentData[i]=1;
            }
            else{
                mostRecentData[i]=0;
            }
            //mostRecentData[i]=sensors[i];

            //Serial.print(sensors[i]);
            //if (i < size-1) Serial.print(", ");
        }
        //Serial.println("");
    }
};

class motor{
    public:
    motor(int stby, int PMW,int dir1, int dir2):stby(stby),PMW(PMW),dir1(dir1),dir2(dir2){
        pinMode(dir1,OUTPUT);
        pinMode(dir2,OUTPUT);
        pinMode(stby,OUTPUT);
        pinMode(PMW,OUTPUT);

    }

    void drive(float power){
         if (forward){
            digitalWrite(dir1,HIGH);
            digitalWrite(dir2,LOW);
         }
         else{
            digitalWrite(dir2,HIGH);
            digitalWrite(dir1,LOW);
         }
         analogWrite(PMW,power);

    }
    int stby;
    int PMW;
    int dir1;
    int dir2;
    bool forward=true;
};

//tilstandsmaskinnnn
float input = 100;
bool serLinje = false;

float forgjeAvik = 0.0;
float integral = 0.0;
float deriverte=0.0;

float K_P = 10;
float K_I = 10;
float K_D = 10;


float PID2(float avik) {
    integral += avik;
    float derivative = avik - forgjeAvik;
    float output = K_P * avik + K_I * integral + K_D * derivative;
    forgjeAvik = avik;
    return output;
}




void setup() {
    Serial.begin(9600); // Start serial communication
    
    Serial.println("Calibration complete!");
}

float flag=0;
sensorData sensor;

void loop() {
    sensor.update();
    auto beep = sensor.seData();
}
