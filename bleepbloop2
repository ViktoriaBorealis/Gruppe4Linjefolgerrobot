#include <Arduino.h>
#include <array>
#include <QTRSensors.h>

QTRSensors qtr;

class sensorData {
    public:
    int size=5;
    int mostRecentData[5];
    std::array<int,5> previousData;
    int numberthingy[5]={50,25,0,-25,-50};
    bool allWhite=false;
    sensorData() {
      qtr.setTypeRC(); // or setTypeAnalog()
    qtr.setSensorPins((const uint8_t[]){D2, D4, D9, D7, D8}, size);
    for (uint8_t i = 0; i < 250; i++)
    {qtr.calibrate();
        delay(20); //hvis vi ikke har denne så blir den aldri ferdig, kan hende vi kan minke den då
        }

    }

    float seData() {
        float avik=0; //Denne vi endrer for å lese
        allWhite=false;
        for (int element: mostRecentData){
            //Serial.print(element);
            if (element != 0){
                allWhite=true;
            }
            avik+=element;
            //Serial.print(",");
        }
        //Serial.println(" ");
        return avik;
    }

    void update() {
        digitalWrite(D2,HIGH); // VELDIG VELDIG , må gjøre det for hver av sensorene
        digitalWrite(D4,HIGH);

        digitalWrite(D7,HIGH);
        digitalWrite(D8,HIGH);
        
        digitalWrite(D9,HIGH);
        //analogWrite(1,HIGH);
        //analogWrite(2,HIGH);
        uint16_t sensors[size];
        int16_t position = qtr.readLineBlack(sensors);
        for (int j = 0; j<size;j++){
                previousData[j]=mostRecentData[j];
            }
        for (uint8_t i = 0; i < size; i++)
        {
            
            
            int threshold = 400;
            if (sensors[i]<threshold){
                mostRecentData[i]=1;
            }
            else{
                mostRecentData[i]=0;
            }
            
            //mostRecentData[i]=sensors[i];

            //Serial.print(sensors[i]);
            //if (i < size-1) Serial.print(", ");
        }
        for (int i =0; i<size; i++){
           
            mostRecentData[i]=mostRecentData[i]*numberthingy[i];
        }
        
        //Serial.println("");
    }
    bool checkForAllWhite(){
            return allWhite;
        }
    std::array<int,5> getLastLine(){
        return previousData;
    }
};

class motor{
    public:
    motor(int stby, int PMW,int dir1, int dir2):stby(stby),PMW(PMW),dir1(dir1),dir2(dir2){
        pinMode(dir1,OUTPUT);
        pinMode(dir2,OUTPUT);
        pinMode(stby,OUTPUT);
        pinMode(PMW,OUTPUT);

    }

    void drive(float power){
         if (forward){
            digitalWrite(dir1,HIGH);
            digitalWrite(dir2,LOW);
         }
         else{
            digitalWrite(dir2,HIGH);
            digitalWrite(dir1,LOW);
         }
         analogWrite(PMW,power);

    }
    int stby;
    int PMW;
    int dir1;
    int dir2;
    bool forward=true;
};

//tilstandsmaskinnnn
float input = 100;
bool serLinje = false;

float forgjeAvik = 0.0;
float integral = 0.0;
float deriverte=0.0;

float K_P = 10;
float K_I = 10;
float K_D = 10;


float PID2(float avik) {
    integral += avik;
    float derivative = avik - forgjeAvik;
    float output = K_P * avik + K_I * integral + K_D * derivative;
    forgjeAvik = avik;
    return output;
}




void setup() {
    Serial.begin(9600); // Start serial communication
    
    Serial.println("Calibration Comence!");
}

float flag=0;
sensorData sensor;
float FlagAvik=0;
void loop() {
    sensor.update();
    if (sensor.checkForAllWhite()){
        std::array<int,5> last=sensor.getLastLine()
        //bassert på hva last sist så så må vi ta en stor sving den veien.
    }
    else{
        float avik = sensor.seData();
        float response = PID2(avik);

         Serial.print(avik);
    Serial.print("; ");
    Serial.println(response);
    

    FlagAvik=avik;
    }
    
   
}
