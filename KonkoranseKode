#include <Arduino.h>
#include <array>
#include <QTRSensors.h>

QTRSensors qtr;

class sensorData {
    public:
    int size=13;
    int mostRecentData[13];
    float flagFloat=0;
    int numberthingy[13]={50,30,25,15,8,2,0,-2,-8,-15,-25,-30,-50}; //Midten her burde egentlig være 0, men med få sensorer så kan det gi issue med allWhite funksjonen
    bool allWhite=false;
    sensorData() {
      qtr.setTypeRC(); // or setTypeAnalog()
    //qtr.setSensorPins((const uint8_t[]){D2, D4,D5,D6,D7,D8,D9}, size);
    qtr.setSensorPins((const uint8_t[]){D13,D11,D9,D8,D7,D6,D5,D4,D3,D2,A0,A1,A2}, size); //A3 og videre er neste rad
    for (uint8_t i = 0; i < 250; i++)
    {qtr.calibrate();
       //Serial.println("Calibratin");
        delay(20); //hvis vi ikke har denne så blir den aldri ferdig, kan hende vi kan minke den då
        }

    }

    float seData() {
        float avik=0; //Denne vi endrer for å lese
        allWhite=true;
        for (int element: mostRecentData){
            //Serial.print(element);
            if (element != 0){
                allWhite=false;
                //allWhite=false;
            }
            //Serial.println(element);
            avik+=element;
            //Serial.print(",");
        }
        //Serial.println(" ");
        return avik;
    }

    void update() {
        digitalWrite(D2,HIGH); // VELDIG VELDIG viktig , må gjøre det for hver av sensorene
        digitalWrite(D4,HIGH);

        digitalWrite(D7,HIGH);
        digitalWrite(D8,HIGH);
        
        digitalWrite(D9,HIGH);
        digitalWrite(D5,HIGH);
        digitalWrite(D6,HIGH);

        digitalWrite(D3,HIGH);
        
        digitalWrite(PC15,HIGH);
        digitalWrite(A0,HIGH);
        digitalWrite(A5,HIGH);
        //analogWrite(1,HIGH);
        //analogWrite(2,HIGH);
        uint16_t sensors[size];
        int16_t position = qtr.readLineBlack(sensors);


        for (uint8_t i = 0; i < size; i++)
        {
            
            
            int threshold = 400; //400
            if (sensors[i]<threshold){
                mostRecentData[i]=1;
            }
            else{
                mostRecentData[i]=0;
            }
            /*
            if (mostRecentData[i] == 1) {
                if (i < size/2) flagFloat = -1;  // linje til venstre
                else if (i > size/2) flagFloat = 1; // linje til høyre
                }
            */
            //mostRecentData[i]=sensors[i];

            //Serial.println(mostRecentData[i]);
            //if (i < size-1) Serial.print(", ");
        }
        //Serial.println("");
        int newAllWHite=0;
        int zeroCount=0;
        for (int i =0; i<size; i++){
           if (mostRecentData[i] >0){
                allWhite=false;
            }
            if (mostRecentData[i]== 0){
                zeroCount+=1;
            }
            mostRecentData[i]=mostRecentData[i]*numberthingy[i];
            newAllWHite+=mostRecentData[i];
            //Serial.print(mostRecentData[i]);
            //Serial.print(",");
            
        }
        if (zeroCount<6){
        if (newAllWHite>0){
            flagFloat=1;
        }
        else if(newAllWHite<0){
            flagFloat=-1;
        }
        }
        if (newAllWHite==0){
            allWhite=true;
        }
        
        
    }

    bool checkForAllWhite(){
            return allWhite;
        }
    float getFlag(){
        return flagFloat;
    }
};

class motor{
    public:
    motor(int stby, int PMW,int dir1, int dir2):stby(stby),PMW(PMW),dir1(dir1),dir2(dir2){
        pinMode(dir1,OUTPUT);
        pinMode(dir2,OUTPUT);
        pinMode(stby,OUTPUT);
        pinMode(PMW,OUTPUT);

    }
    void panikkSnu(bool framover){
        if (framover){
            digitalWrite(dir1,HIGH);
            digitalWrite(dir2,LOW);
        }
        else{
            digitalWrite(dir2,HIGH);
            digitalWrite(dir1,LOW);
        }
        analogWrite(PMW,255);
    }

    void drive(int power){
        power=power*directionalMultiplier;
      digitalWrite(stby,HIGH);
         if (forward){
            digitalWrite(dir1,HIGH);
            digitalWrite(dir2,LOW);
         }
         else{
            digitalWrite(dir2,HIGH);
            digitalWrite(dir1,LOW);
         }
         int pwm = power + drivingVariable;
        pwm = constrain(pwm, 0, 255);
        //Serial.println(pwm);
        //HEr er problemet enn så lenge, vi vil at den skal kjøre framover men bare ett av hjulene kjører om gangen. Why

        float TOTEST=pwm*0.7; //0.4
        //Serial.println(TOTEST);
        analogWrite(PMW,TOTEST);
        // analogWrite(PMW,pwm);

    }
    int stby;
    int PMW;
    int dir1;
    int dir2;
    float drivingVariable=255;
    bool forward=true;
    int directionalMultiplier=1;
};
//tilstandsmaskinnnn
float input = 100;
bool serLinje = false;

float forgjeAvik = 0.0;
float integral = 0.0;
float deriverte=0.0;

float K_P = 3.75; 
float K_I = 0;
float K_D = 0.002;


float PID2(float avik) {
    integral += avik;
    float derivative = avik - forgjeAvik;
    float output = K_P * avik + K_I * integral + K_D * derivative;
    forgjeAvik = avik;
    if (output >=250){
        output=249;
        integral-=avik;
    }
    else if(output <=-250){
        output=-249;
        integral+=avik;
    }
    return output;
}





motor motor1(PC5,PB6,PC8,PC6); //PB1 //PA6
motor motor2(PC5,PA6,PC9,PB8); //PA8 //PB6

void setup() {
    //Serial.begin(9600); // Start serial communication
    //motor2.directionalMultiplier=-1;
    motor1.directionalMultiplier=-1;
    //Serial.println("Calibration Comence!");
}

float flag=0;
sensorData sensor;
float FlagAvik=0;

int mengdepanikk=0;
void loop() {
    float response=0;
    sensor.update();
    if (sensor.checkForAllWhite()){
        mengdepanikk+=1;
        //bassert på hva last sist så så må vi ta en stor sving den veien.
        if (mengdepanikk>3){
            float panikkvei=sensor.getFlag();
            //Serial.println(panikkvei);
            if (panikkvei > 0){
                //motor kjør en av veiene
                motor1.panikkSnu(true);
                motor2.panikkSnu(false);   
            }
            else{
                motor1.panikkSnu(false);
                motor2.panikkSnu(true);   
            }
            mengdepanikk=0;
        }
    }
    else{
        float avik = sensor.seData();
        response = PID2(-avik);
        motor1.drive(response);
        motor2.drive(response);
        
        // Reset panikkteller når vi ser linjen igjen
        mengdepanikk = 0;
    }
}
