#include <Arduino.h>
#include <QTRSensors.h>

QTRSensors qtr;

class sensorData {
public:
    int size = 13;
    int mostRecentData[13];
    int numberthingy[13] = {50, 30, 25, 15, 8, 2, 0, -2, -8, -15, -25, -30, -50};
    float flagFloat = 0; // siste kjente retning
    bool hasLine = true;

    sensorData() {
        qtr.setTypeRC();
        qtr.setSensorPins((const uint8_t[]){D13,D11,D9,D8,D7,D6,D5,D4,D3,D2,A0,A1,A2}, size);
        for (uint8_t i = 0; i < 250; i++) {
            qtr.calibrate();
            delay(20);
        }
    }

    void update() {
        uint16_t sensors[size];
        qtr.readLineBlack(sensors);

        for (int i = 0; i < size; i++) {
            int threshold = 400;
            mostRecentData[i] = (sensors[i] < threshold) ? numberthingy[i] : 0;
        }
    }

    float seData() {
        float sum = 0;
        bool lineDetected = false;

        for (int i = 0; i < size; i++) {
            sum += mostRecentData[i];
            if (mostRecentData[i] != 0) lineDetected = true;
        }

        hasLine = lineDetected;

        // Oppdater flagFloat kun hvis linjen faktisk blir sett til venstre eller høyre
        if (lineDetected) {
            if (sum > 0) flagFloat = 1;
            else if (sum < 0) flagFloat = -1;
            // Hvis sum ~ 0, beholder flagFloat siste kjente retning
        }

        return sum;
    }
};

class motor {
public:
    int stby, PMW, dir1, dir2;
    int directionalMultiplier = 1;
    bool forward = true;
    float drivingVariable = 0;

    motor(int stbyPin, int pwmPin, int d1, int d2) : stby(stbyPin), PMW(pwmPin), dir1(d1), dir2(d2) {
        pinMode(stby, OUTPUT);
        pinMode(PMW, OUTPUT);
        pinMode(dir1, OUTPUT);
        pinMode(dir2, OUTPUT);
    }

    void drive(int power) {
        power = power * directionalMultiplier;
        digitalWrite(stby, HIGH);
        if (forward) {
            digitalWrite(dir1, HIGH);
            digitalWrite(dir2, LOW);
        } else {
            digitalWrite(dir2, HIGH);
            digitalWrite(dir1, LOW);
        }
        int pwm = constrain(power + drivingVariable, 0, 255);
        analogWrite(PMW, pwm);
    }

    void panikkSnu(bool framover) {
        digitalWrite(stby, HIGH);
        if (framover) {
            digitalWrite(dir1, HIGH);
            digitalWrite(dir2, LOW);
        } else {
            digitalWrite(dir2, HIGH);
            digitalWrite(dir1, LOW);
        }
        analogWrite(PMW, 255);
    }
};

// PID-parametre
float K_P = 3.75;
float K_I = 0;
float K_D = 0;
float forgjeAvik = 0.0;
float integral = 0.0;

float PID2(float avik) {
    integral += avik;
    float derivative = avik - forgjeAvik;
    float output = K_P * avik + K_I * integral + K_D * derivative;
    forgjeAvik = avik;

    if (output >= 250) {
        output = 249;
        integral -= avik;
    } else if (output <= -250) {
        output = -249;
        integral += avik;
    }
    return output;
}

// Motorer og sensor
motor motor1(PC5, PB6, PC8, PC6);
motor motor2(PC5, PA6, PC9, PB8);
sensorData sensor;

// Panikk-teller
int mengdepanikk = 0;

void setup() {
    motor1.directionalMultiplier = -1; // juster motorretning om nødvendig
}

void loop() {
    sensor.update();
    float avik = sensor.seData();

    if (sensor.hasLine) {
        // PID-kjøring
        float response = PID2(-avik);
        // Alltid fremover som baseline
        motor1.forward = true;
        motor2.forward = true;
        motor1.drive(response);
        motor2.drive(response);
        mengdepanikk = 0; // reset panikk-teller
    } else {
        // Panikk når linjen forsvinner
        mengdepanikk++;
        if (mengdepanikk > 3) {
            if (sensor.flagFloat >= 0) {
                motor1.panikkSnu(true);
                motor2.panikkSnu(false);
            } else {
                motor1.panikkSnu(false);
                motor2.panikkSnu(true);
            }
            mengdepanikk = 0;
        }
    }
}
